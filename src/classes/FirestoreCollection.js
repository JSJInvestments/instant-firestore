import Default from './Default';
import { asyncForEach } from 'instant-utils';
import { getCollection, deserializeReferences } from '../utils';

// Note the difference between `Firestore Document` and `document` in the comments - the latter is a serialized representation of the former

export default class FirestoreCollection extends Default {
  /**
   * Constructor
   * @param {object} db Firestore Database instance
   * @param {string} colRef Firestore Collection Reference
   */
  constructor(db, colRef) {
    super();
    Default.bind(this, ['create', 'createMany', 'find', 'findOne']);
    this.db = db;
    this.colRef = typeof colRef === 'string' ? db.collection(colRef) : colRef;
  }

  /**
   * Create a Firestore Document (`id` is generated by Firestore)
   * Note: to create a document with an `id` use FirestoreDocument.create
   * @param {object} attributes Document attributes
   * @param {object} options Options
   */
  async create(attributes, options = {}) {
    try {
      deserializeReferences(attributes, this.db);
      const docRef = await this.colRef.add(attributes);
      if (docRef.id) {
        return docRef.id;
      }
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  /**
   * Create many Firestore Documents
   * @param {array} arr Array of Document attributes
   * @param {object} options Options
   */
  async createMany(arr, options = {}) {
    try {
      let ids = [];
      const batch = this.db.batch();
      await asyncForEach(arr, async attributes => {
        const id = await this.create(attributes, options);
        ids.push(id);
      });
      batch.commit();
      return ids;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  /**
   * Find documents
   * @param {object} query Search query
   * @param {object} options Options
   */
  async find(query = {}, options = {}) {
    try {
      // Convert the query into an array of queries for Firestore
      const queries = Array.isArray(query)
        ? query
        : Object.keys(query).map(k => [k, '==', query[k]]);
      // Baseline query reference
      let queryRef = this.colRef;
      // Add the queries to the query reference
      queries.forEach(query => {
        queryRef = queryRef.where(query[0], query[1], query[2]);
      });
      // Order if necessary
      if (options.orderBy && typeof options.orderBy === 'string') {
        queryRef = queryRef.orderBy(options.orderBy);
      } else if (options.orderBy) {
        queryRef = queryRef.orderBy(...options.orderBy);
      }
      // Apply a limit if necessary
      if (options.limit) {
        queryRef = queryRef.limit(options.limit);
      }
      // Perform the get request
      return await getCollection(queryRef, options);
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  /**
   * Find one document
   * @param {object} query Search query
   * @param {object} options Options
   */
  async findOne(query, options = {}) {
    try {
      const items = await this.find(query, { ...options, limit: 1 });
      if (items) {
        return items[0];
      }
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}
